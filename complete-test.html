<!DOCTYPE html>
<html>
<head>
    <title>Complete Image Testing Environment</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        .image-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
            padding: 1rem;
        }
        .image-card {
            border: 1px solid #e5e7eb;
            border-radius: 0.75rem;
            overflow: hidden;
            background: white;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .image-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }
        .image-card img {
            width: 100%;
            height: var(--thumb-h, 250px); /* thumbnail height follows slider */
            object-fit: cover;
            cursor: pointer;
        }
        .image-info {
            padding: 1rem;
        }
        .drop-zone {
            border: 3px dashed #d1d5db;
            border-radius: 1rem;
            padding: 3rem;
            text-align: center;
            transition: all 0.3s;
            background: #f9fafb;
        }
        .drop-zone.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
            transform: scale(1.02);
        }
        .color-row {
            display: flex;
            align-items: center;
            gap: 0.5rem; /* replaces circle margin */
            flex-wrap: nowrap;  /* single line */
            overflow: hidden;   /* hide overflow if any */
        }
        .color-circle {
            width: 2rem;  /* will be overridden inline to fit */
            height: 2rem;
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            display: inline-block;
            cursor: pointer;
            flex: 0 0 auto;     /* fixed-size items */
            transition: transform 0.15s, width 0.15s, height 0.15s;
        }
        .color-circle:hover {
            transform: scale(1.2);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(4px);
        }
        .modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: white;
            border-radius: 1rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }
        .modal-image {
            max-width: 100%;
            max-height: 60vh;
            object-fit: contain;
        }
        .test-section {
            background: white;
            border-radius: 1rem;
            padding: 1.5rem; /* unified section padding */
            margin-bottom: 1rem; /* unified vertical rhythm */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .status-success {
            background-color: #dcfce7;
            color: #166534;
        }
        .status-error {
            background-color: #fef2f2;
            color: #dc2626;
        }
        .status-warning {
            background-color: #fef3c7;
            color: #d97706;
        }
        .progress-bar {
            width: 100%;
            height: 0.5rem;
            background-color: #e5e7eb;
            border-radius: 0.25rem;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            transition: width 0.3s ease;
        }
        /* Compact variant aligned to global rhythm */
        .compact-section { padding: 1rem; }
        .drop-zone.compact { padding: 1rem; }
    </style>
  </head>
  <body class="bg-gray-100">
    <script>
      // Toggleable debug for search term construction
      window.DEBUG_SEARCH = false;
    </script>
    <!-- Image Modal -->
    <div id="imageModal" class="modal">
        <div class="modal-content">
            <div class="p-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-gray-900">Image Details</h3>
                    <button id="closeModal" class="text-gray-400 hover:text-gray-600 text-2xl">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="flex flex-col lg:flex-row gap-6">
                    <div class="flex-1">
                        <img id="modalImage" src="" alt="Preview" class="modal-image rounded-lg">
                    </div>
                    <div class="flex-1 space-y-4">
                        <div id="modalMetadata" class="space-y-3">
                            <!-- Metadata will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="container mx-auto px-4 py-4 max-w-7xl">
        <header class="text-center mb-4">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">Complete Image Testing Environment</h1>
            <p class="text-lg text-gray-600">Comprehensive testing for image loading, display, and processing</p>
        </header>

        <!-- Top Panels: Status (1/3) + Upload (2/3) on desktop -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
            <!-- Test Status Overview -->
            <div class="test-section compact-section h-full lg:col-span-1">
                <h2 class="text-xl font-semibold text-gray-800 mb-2">Test Status Overview</h2>
                <div class="grid grid-cols-1 gap-2">
                    <div class="bg-gray-50 p-2.5 rounded-lg">
                        <div class="text-xs text-gray-600">Images Loaded</div>
                        <div class="text-xl font-bold text-blue-600" id="loadedCount">0</div>
                    </div>
                    <div class="bg-gray-50 p-2.5 rounded-lg">
                        <div class="text-xs text-gray-600">Successful</div>
                        <div class="text-xl font-bold text-green-600" id="successCount">0</div>
                    </div>
                    <div class="bg-gray-50 p-2.5 rounded-lg">
                        <div class="text-xs text-gray-600">Failed</div>
                        <div class="text-xl font-bold text-red-600" id="failedCount">0</div>
                    </div>
                </div>
            </div>

            <!-- Upload Section -->
            <div class="test-section compact-section h-full lg:col-span-2">
                <h2 class="text-xl font-semibold text-gray-800 mb-2">Upload Test Images</h2>
                
                <div id="dropZone" class="drop-zone compact" style="min-height: 150px;">
                    <div class="flex flex-col items-center justify-center">
                        <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-2"></i>
                        <h3 class="text-lg font-semibold text-gray-700 mb-1.5">Drop Images Here</h3>
                        <p class="text-gray-500 mb-2 text-sm">or click to select files</p>
                        <input type="file" id="fileInput" multiple accept="image/*" class="hidden">
                        <button id="selectBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium text-sm">
                            <i class="fas fa-folder-open mr-2"></i>Select Images
                        </button>
                        <p class="text-xs text-gray-400 mt-2">Supports: PNG, JPG, JPEG, GIF, WebP</p>
                    </div>
                </div>
                
                <div id="uploadProgress" class="mt-4 hidden">
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-sm text-gray-600">Processing images...</span>
                        <span id="progressText" class="text-sm text-gray-600">0/0</span>
                    </div>
                    <div class="progress-bar">
                        <div id="progressFill" class="progress-fill" style="width: 0%"></div>
                    </div>
                </div>
                
                <div id="uploadStatus" class="mt-4 text-center"></div>
            </div>
        </div>

        <!-- Search and Sort Controls -->
        <div class="test-section compact-section mt-4">
            <h2 class="text-xl font-semibold text-gray-800 mb-2">Search & Filter</h2>
            <div class="flex flex-wrap gap-3 items-center">
                <div class="flex items-center space-x-2">
                    <label for="sortBy" class="text-sm font-medium text-gray-700">Sort by:</label>
                    <select id="sortBy" class="border border-gray-300 rounded-md px-3 py-1.5 text-sm focus:ring-blue-500 focus:border-blue-500">
                        <option value="newest">Newest First</option>
                        <option value="oldest">Oldest First</option>
                        <option value="name-asc">Name (A-Z)</option>
                        <option value="name-desc">Name (Z-A)</option>
                        <option value="primary-asc">Primary Color (A-Z)</option>
                        <option value="primary-desc">Primary Color (Z-A)</option>
                    </select>
                </div>
                
                <div class="flex items-center space-x-2">
                    <label for="filterTag" class="text-sm font-medium text-gray-700">Filter by tag:</label>
                    <select id="filterTag" class="border border-gray-300 rounded-md px-3 py-1.5 text-sm focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Tags</option>
                        <!-- Will be populated by JavaScript -->
                    </select>
                </div>
                
                <div class="flex-1 min-w-[200px]">
                    <input type="text" id="searchInput" placeholder="Search images..." class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-blue-500 focus:border-blue-500">
                </div>
                
                <div class="flex items-center space-x-2">
                    <label for="filterPrimary" class="text-sm font-medium text-gray-700">Primary color:</label>
                    <select id="filterPrimary" class="border border-gray-300 rounded-md px-3 py-1.5 text-sm focus:ring-blue-500 focus:border-blue-500">
                        <option value="">All Colors</option>
                        <option value="black">Black</option>
                        <option value="white">White</option>
                        <option value="gray">Gray</option>
                        <option value="brown">Brown</option>
                        <option value="red">Red</option>
                        <option value="orange">Orange</option>
                        <option value="yellow">Yellow</option>
                        <option value="green">Green</option>
                        <option value="cyan">Cyan</option>
                        <option value="blue">Blue</option>
                        <option value="purple">Purple</option>
                        <option value="pink">Pink</option>
                    </select>
                </div>
                
                <div class="flex items-center space-x-2">
                    <span class="text-sm font-medium text-gray-700">Grid Size:</span>
                    <div class="flex items-center space-x-2 w-44">
                        <i class="fas fa-th text-gray-500 text-sm"></i>
                        <input type="range" min="100" max="500" value="150" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" id="gridSizeSlider">
                        <i class="fas fa-th-large text-gray-500 text-sm"></i>
                        <span id="gridSizeValue" class="text-sm text-gray-600 w-12 text-center">150px</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Test Results -->
        <div class="test-section compact-section">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-semibold text-gray-800">Test Results</h2>
                <div class="flex gap-2">
                    <button id="clearAll" class="px-3.5 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                        <i class="fas fa-trash mr-2"></i>Clear All
                    </button>
                    <button id="exportResults" class="px-3.5 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors">
                        <i class="fas fa-download mr-2"></i>Export Results
                    </button>
                </div>
            </div>
            
            <div id="imageGrid" class="image-grid">
                <div class="col-span-full text-center py-6 text-gray-500">
                    <i class="fas fa-images text-4xl mb-4"></i>
                    <p class="text-lg">No images uploaded yet</p>
                    <p class="text-sm">Upload some images to start testing!</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let loadedImages = [];
        let testResults = {
            total: 0,
            successful: 0,
            failed: 0,
            errors: []
        };
        
        // Backend configuration
        const API_BASE_URL = 'http://localhost:8000';
        let backendConnected = false;

        // DOM elements
        const fileInput = document.getElementById('fileInput');
        const selectBtn = document.getElementById('selectBtn');
        const dropZone = document.getElementById('dropZone');
        const imageGrid = document.getElementById('imageGrid');
        const uploadProgress = document.getElementById('uploadProgress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const uploadStatus = document.getElementById('uploadStatus');
        const loadedCount = document.getElementById('loadedCount');
        const successCount = document.getElementById('successCount');
        const failedCount = document.getElementById('failedCount');
        const clearAll = document.getElementById('clearAll');
        const exportResults = document.getElementById('exportResults');
        const imageModal = document.getElementById('imageModal');
        const modalImage = document.getElementById('modalImage');
        const modalMetadata = document.getElementById('modalMetadata');
        const closeModal = document.getElementById('closeModal');
        const sortBy = document.getElementById('sortBy');
        const filterTag = document.getElementById('filterTag');
        const filterPrimary = document.getElementById('filterPrimary');
        const searchInput = document.getElementById('searchInput');
        const gridSizeSlider = document.getElementById('gridSizeSlider');
        const gridSizeValue = document.getElementById('gridSizeValue');

        // Initialize
        let refitColorRows; // debounced refit function
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            updateGridSize(); // initialize grid and thumbnail height
            checkBackendConnection();
            // Prepare debounced refit and run once
            refitColorRows = debounce(fitAllColorRows, 120);
            fitAllColorRows();
            window.addEventListener('resize', () => refitColorRows());
        });

        async function checkBackendConnection() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/images`);
                if (response.ok) {
                    backendConnected = true;
                    showBackendStatus('‚úÖ Backend Connected - AI Processing Available', 'success');
                    // Intentionally do not auto-load existing images to avoid preloading many files
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                backendConnected = false;
                showBackendStatus('‚ö†Ô∏è Backend Disconnected - Using Browser-Only Mode', 'warning');
                console.warn('Backend not available:', error.message);
            }
        }

        function showBackendStatus(message, type) {
            const statusDiv = document.createElement('div');
            statusDiv.className = `status-badge status-${type} mb-4`;
            statusDiv.innerHTML = `<i class="fas fa-server mr-2"></i>${message}`;
            
            // Insert after the header
            const header = document.querySelector('header');
            header.insertAdjacentElement('afterend', statusDiv);
        }

        async function loadExistingImages() {
            if (!backendConnected) return;
            try {
                showProgress(true);
                const response = await fetch(`${API_BASE_URL}/api/images`);
                const payload = await response.json();
                const existingImages = Array.isArray(payload) ? payload : (payload.images || []);
                for (const imageData of existingImages) {
                    const md = imageData.metadata || {};
                    const processedImage = {
                        id: Date.now() + Math.random(),
                        name: imageData.filename,
                        size: (md.size_mb || 0) * 1024 * 1024,
                        type: (md.format ? md.format : ('image/' + imageData.filename.split('.').pop().toLowerCase())),
                        dimensions: md.dimensions || '',
                        dataUrl: `${API_BASE_URL}${imageData.path}`,
                        loadSuccess: true,
                        timestamp: new Date().toISOString(),
                        aiProcessed: true,
                        caption: md.caption || '',
                        tags: md.tags || [],
                        allTags: md.all_tags || [],
                        colors: md.colors || [],
                        backendPath: imageData.path,
                        format: md.format || ''
                    };
                    loadedImages.push(processedImage);
                    testResults.total++;
                    testResults.successful++;
                    renderImage(processedImage);
                }
                updateStatus();
            } catch (error) {
                console.error('Error loading existing images:', error);
            } finally {
                showProgress(false);
            }
        }

        function setupEventListeners() {
            selectBtn.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFiles);
            clearAll.addEventListener('click', clearAllImages);
            exportResults.addEventListener('click', exportTestResults);
            closeModal.addEventListener('click', hideModal);
            
            // Drag and drop
            dropZone.addEventListener('dragover', handleDragOver);
            dropZone.addEventListener('dragleave', handleDragLeave);
            dropZone.addEventListener('drop', handleDrop);
            
            // Modal close on background click
            imageModal.addEventListener('click', (e) => {
                if (e.target === imageModal) hideModal();
            });
            
            // Search and sort controls
            sortBy.addEventListener('change', updateSort);
            filterTag.addEventListener('change', updateFilter);
            filterPrimary.addEventListener('change', updateFilterPrimary);
            searchInput.addEventListener('input', updateSearch);
            gridSizeSlider.addEventListener('input', updateGridSize);
        }

        function handleDragOver(e) {
            e.preventDefault();
            dropZone.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
        }

        function handleDrop(e) {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles({ target: { files: e.dataTransfer.files } });
        }

        function handleFiles(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            showProgress(true);
            testResults.total += files.length;
            
            let processedCount = 0;
            
            files.forEach((file, index) => {
                if (file.type.startsWith('image/')) {
                    // Use backend processing if connected, otherwise fallback to browser-only
                    if (backendConnected) {
                        processImageWithBackend(file, () => {
                            processedCount++;
                            updateProgress(processedCount, files.length);
                            
                            if (processedCount === files.length) {
                                showProgress(false);
                                updateStatus();
                            }
                        });
                    } else {
                        processImage(file, () => {
                            processedCount++;
                            updateProgress(processedCount, files.length);
                            
                            if (processedCount === files.length) {
                                showProgress(false);
                                updateStatus();
                            }
                        });
                    }
                } else {
                    processedCount++;
                    updateProgress(processedCount, files.length);
                    
                    if (processedCount === files.length) {
                        showProgress(false);
                        updateStatus();
                    }
                }
            });
        }

        async function processImageWithBackend(file, callback) {
            const formData = new FormData();
            formData.append('file', file);
            
            try {
                console.log(`üöÄ Uploading ${file.name} to backend for AI processing...`);
                
                const response = await fetch(`${API_BASE_URL}/api/upload`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (response.ok && result.status === 'success') {
                    // Success - create image data with AI metadata
                    const imageData = {
                        id: Date.now() + Math.random(),
                        name: result.filename,
                        size: file.size,
                        type: file.type,
                        dataUrl: `${API_BASE_URL}${result.path}`,
                        loadSuccess: true,
                        timestamp: new Date().toISOString(),
                        // Backend AI processing results
                        aiProcessed: true,
                        caption: result.metadata?.caption || 'No caption generated',
                        tags: result.metadata?.tags || [],
                        allTags: result.metadata?.all_tags || [],
                        colors: result.metadata?.colors || [],
                        backendPath: result.path,
                        processingTime: Date.now() - Date.now() // Will be calculated properly
                    };
                    
                    loadedImages.push(imageData);
                    testResults.successful++;
                    renderImage(imageData);
                    
                    console.log(`‚úÖ Successfully processed ${file.name} with AI`);
                    
                } else {
                    // Backend processing failed
                    const imageData = {
                        id: Date.now() + Math.random(),
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        error: result.error || `Backend error: ${response.status}`,
                        loadSuccess: false,
                        timestamp: new Date().toISOString(),
                        aiProcessed: false,
                        backendError: true
                    };
                    
                    loadedImages.push(imageData);
                    testResults.failed++;
                    testResults.errors.push(`${file.name}: ${imageData.error}`);
                    renderImage(imageData);
                    
                    console.error(`‚ùå Backend processing failed for ${file.name}:`, result.error);
                }
                
            } catch (error) {
                // Network or other error
                const imageData = {
                    id: Date.now() + Math.random(),
                    name: file.name,
                    size: file.size,
                    type: file.type,
                    error: `Network error: ${error.message}`,
                    loadSuccess: false,
                    timestamp: new Date().toISOString(),
                    aiProcessed: false,
                    networkError: true
                };
                
                loadedImages.push(imageData);
                testResults.failed++;
                testResults.errors.push(`${file.name}: Network error - ${error.message}`);
                renderImage(imageData);
                
                console.error(`üåê Network error processing ${file.name}:`, error);
            }
            
            callback();
        }

        function processImage(file, callback) {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const img = new Image();
                
                img.onload = () => {
                    // Simulate color extraction
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    const colors = extractDominantColors(canvas, ctx);
                    
                    const imageData = {
                        id: Date.now() + Math.random(),
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        dimensions: `${img.width}x${img.height}`,
                        dataUrl: e.target.result,
                        colors: colors,
                        loadSuccess: true,
                        timestamp: new Date().toISOString()
                    };
                    
                    loadedImages.push(imageData);
                    testResults.successful++;
                    renderImage(imageData);
                    callback();
                };
                
                img.onerror = () => {
                    const imageData = {
                        id: Date.now() + Math.random(),
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        error: 'Failed to load image',
                        loadSuccess: false,
                        timestamp: new Date().toISOString()
                    };
                    
                    loadedImages.push(imageData);
                    testResults.failed++;
                    testResults.errors.push(`${file.name}: Failed to load`);
                    renderImage(imageData);
                    callback();
                };
                
                img.src = e.target.result;
            };
            
            reader.onerror = () => {
                testResults.failed++;
                testResults.errors.push(`${file.name}: FileReader error`);
                callback();
            };
            
            reader.readAsDataURL(file);
        }

        function extractDominantColors(canvas, ctx) {
            // Advanced color extraction with distinctness filtering
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const colorMap = new Map();
            const totalPixels = canvas.width * canvas.height;
            
            // Sample every 10th pixel to improve performance
            let sampledPixelCount = 0;
            for (let i = 0; i < data.length; i += 40) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const alpha = data[i + 3];
                
                if (alpha > 128) { // Only consider non-transparent pixels
                    // Quantize colors to reduce similar variations
                    const quantizedR = Math.round(r / 16) * 16;
                    const quantizedG = Math.round(g / 16) * 16;
                    const quantizedB = Math.round(b / 16) * 16;
                    const color = `rgb(${quantizedR},${quantizedG},${quantizedB})`;
                    colorMap.set(color, (colorMap.get(color) || 0) + 1);
                    sampledPixelCount++;
                }
            }
            
            // Get initial color candidates
            const colorCandidates = Array.from(colorMap.entries())
                .sort((a, b) => b[1] - a[1])
                .map(([color, count]) => {
                    const percentage = ((count / sampledPixelCount) * 100).toFixed(1);
                    const estimatedPixels = Math.round((count / sampledPixelCount) * totalPixels);
                    return {
                        color: color,
                        count: count,
                        estimatedPixels: estimatedPixels,
                        percentage: percentage,
                        hex: rgbToHex(color),
                        rgb: parseRgb(color)
                    };
                });
            
            // Filter for distinct colors using color distance
            const distinctColors = [];
            const minColorDistance = 80; // Minimum color difference threshold
            
            for (const candidate of colorCandidates) {
                let isDistinct = true;
                
                // Check if this color is too similar to already selected colors
                for (const selected of distinctColors) {
                    const distance = calculateColorDistance(candidate.rgb, selected.rgb);
                    if (distance < minColorDistance) {
                        isDistinct = false;
                        // Merge similar colors by adding counts to the more dominant one
                        selected.count += candidate.count;
                        selected.estimatedPixels += candidate.estimatedPixels;
                        selected.percentage = ((selected.count / sampledPixelCount) * 100).toFixed(1);
                        break;
                    }
                }
                
                if (isDistinct) {
                    distinctColors.push(candidate);
                }
                
                // Stop when we have 5 distinct colors
                if (distinctColors.length >= 5) break;
            }
            
            return distinctColors.sort((a, b) => b.count - a.count);
        }
        
        function parseRgb(rgbString) {
            const match = rgbString.match(/rgb\((\d+),(\d+),(\d+)\)/);
            return match ? {
                r: parseInt(match[1]),
                g: parseInt(match[2]),
                b: parseInt(match[3])
            } : { r: 0, g: 0, b: 0 };
        }
        
        function calculateColorDistance(rgb1, rgb2) {
            // Calculate Euclidean distance in RGB space
            const dr = rgb1.r - rgb2.r;
            const dg = rgb1.g - rgb2.g;
            const db = rgb1.b - rgb2.b;
            return Math.sqrt(dr * dr + dg * dg + db * db);
        }

        function rgbToHex(rgb) {
            const match = rgb.match(/rgb\((\d+),(\d+),(\d+)\)/);
            if (!match) return '#000000';
            
            const r = parseInt(match[1]);
            const g = parseInt(match[2]);
            const b = parseInt(match[3]);
            
            return '#' + [r, g, b].map(x => {
                const hex = x.toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            }).join('');
        }

        // Primary color helpers (client-side), computed from existing dominant colors
        function rgbToHslJS(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r,g,b), min = Math.min(r,g,b);
            let h, s, l = (max + min) / 2;
            if (max === min) { h = 0; s = 0; }
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h *= 60;
            }
            return [h, s, l];
        }
        function mapRgbToPrimaryJS(r, g, b) {
            const [h, s, l] = rgbToHslJS(r, g, b);
            if (l <= 0.12) return 'black';
            if (l >= 0.9 && s <= 0.25) return 'white';
            if (s <= 0.12) return 'gray';
            if (l < 0.5 && s < 0.6 && (h >= 20 && h < 50)) return 'brown';
            if (h >= 345 || h < 15) return 'red';
            if (h >= 15 && h < 35) return 'orange';
            if (h >= 35 && h < 65) return 'yellow';
            if (h >= 65 && h < 165) return 'green';
            if (h >= 165 && h < 200) return 'cyan';
            if (h >= 200 && h < 255) return 'blue';
            if (h >= 255 && h < 300) return 'purple';
            if (h >= 300 && h < 345) return 'pink';
            return 'gray';
        }
        function aggregatePrimaryFromDominantJS(colors) {
            const buckets = {};
            (colors || []).forEach(c => {
                const hex = c.hex || '#000000';
                const m = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                let r=0,g=0,b=0;
                if (m) { r = parseInt(m[1],16); g = parseInt(m[2],16); b = parseInt(m[3],16); }
                const name = mapRgbToPrimaryJS(r,g,b);
                const pct = parseFloat(c.percentage || 0);
                buckets[name] = (buckets[name] || 0) + (isNaN(pct) ? 0 : pct);
            });
            const PRIMARY_ORDER = ["black","white","gray","brown","red","orange","yellow","green","cyan","blue","purple","pink"];
            const list = Object.entries(buckets).map(([name, pct]) => ({ name, percentage: Math.round(pct*10)/10 }));
            list.sort((a,b) => b.percentage - a.percentage || PRIMARY_ORDER.indexOf(a.name) - PRIMARY_ORDER.indexOf(b.name));
            return list;
        }

        // Compute and cache primary color on image object when needed
        function getPrimaryColor(image) {
            if (image.primaryColor) return image.primaryColor;
            const list = aggregatePrimaryFromDominantJS(image.colors || []);
            image.primaryColor = (list[0] && list[0].name) ? list[0].name : '';
            return image.primaryColor;
        }

        function renderImage(imageData) {
            const card = document.createElement('div');
            card.className = 'image-card';
            card.onclick = () => showModal(imageData);
            
            if (imageData.loadSuccess) {
                const colorsHtml = imageData.colors.map(color => 
                    `<div class="color-circle" style="background-color: ${color.hex}" title="${color.hex}"></div>`
                ).join('');
                
                card.innerHTML = `
                    <img src="${imageData.dataUrl}" alt="${imageData.name}" loading="lazy">
                    <div class="image-info">
                        <h3 class="font-semibold text-gray-900 truncate mb-2">${imageData.name}</h3>
                        <div class="text-sm text-gray-600 space-y-1">
                            <div><strong>Size:</strong> ${formatFileSize(imageData.size)}</div>
                            <div><strong>Type:</strong> ${imageData.type}</div>
                            ${imageData.dimensions ? `<div><strong>Dimensions:</strong> ${imageData.dimensions}</div>` : ''}
                            <div><strong>Loaded:</strong> ${new Date(imageData.timestamp).toLocaleString()}</div>
                        </div>
                        <div class="mt-3">
                            <div class="text-sm font-medium text-gray-700 mb-2">Dominant Colors:</div>
                            <div class="color-row">${colorsHtml}</div>
                        </div>
                        <div class="mt-3">
                            <span class="status-badge status-success">
                                <i class="fas fa-check mr-1"></i>Loaded Successfully
                            </span>
                        </div>
                    </div>
                `;

                // Compute and fill missing dimensions asynchronously (helps backend images)
                if (!imageData.dimensions) {
                    const tempImg = new Image();
                    tempImg.onload = () => {
                        imageData.dimensions = `${tempImg.width}x${tempImg.height}`;
                        const dimEl = card.querySelector('.dim-text');
                        if (dimEl) dimEl.innerHTML = `<strong>Dimensions:</strong> ${imageData.dimensions}`;
                    };
                    tempImg.src = imageData.dataUrl;
                }
            } else {
                card.innerHTML = `
                    <div class="h-64 bg-gray-200 flex items-center justify-center">
                        <i class="fas fa-exclamation-triangle text-red-500 text-4xl"></i>
                    </div>
                    <div class="image-info">
                        <h3 class="font-semibold text-gray-900 truncate mb-2">${imageData.name}</h3>
                        <div class="text-sm text-gray-600 space-y-1">
                            <div><strong>Size:</strong> ${formatFileSize(imageData.size)}</div>
                            <div><strong>Type:</strong> ${imageData.type}</div>
                        </div>
                        <div class="mt-3">
                            <span class="status-badge status-error">
                                <i class="fas fa-times mr-1"></i>Failed to Load
                            </span>
                        </div>
                        <div class="mt-2 text-sm text-red-600">${imageData.error}</div>
                    </div>
                `;
            }
            
            // Clear placeholder if this is the first image
            if (imageGrid.children.length === 1 && imageGrid.children[0].textContent.includes('No images')) {
                imageGrid.innerHTML = '';
            }
            
            imageGrid.appendChild(card);
            // Ensure color circles fit on one line for this card
            if (typeof refitColorRows === 'function') { refitColorRows(); } else { fitAllColorRows(); }
        }

        function showModal(imageData) {
            modalImage.src = imageData.dataUrl;
            
            let metadataHtml = `
                <div class="space-y-4">
                    <div>
                        <h4 class="font-semibold text-gray-900 mb-2">File Information</h4>
                        <div class="bg-gray-50 p-3 rounded-lg space-y-1 text-sm">
                            <div><strong>Name:</strong> ${imageData.name}</div>
                            <div><strong>Size:</strong> ${formatFileSize(imageData.size)}</div>
                            <div><strong>Type:</strong> ${imageData.type}</div>
                            ${imageData.dimensions ? `<div><strong>Dimensions:</strong> ${imageData.dimensions}</div>` : ''}
                            <div><strong>Loaded:</strong> ${new Date(imageData.timestamp).toLocaleString()}</div>
                        </div>
                    </div>
            `;
            
            if (imageData.colors && imageData.colors.length > 0) {
                const colorsHtml = imageData.colors.map((color, index) => `
                    <div class="flex items-center space-x-2">
                        <div class="color-circle" style="background-color: ${color.hex}"></div>
                        <div class="text-sm">
                            <div class="font-medium">${color.hex}</div>
                            <div class="text-gray-500">${color.count} pixels (${color.percentage}% of sampled pixels, estimated ${color.estimatedPixels} pixels)</div>
                        </div>
                    </div>
                `).join('');
                
                metadataHtml += `
                    <div>
                        <h4 class="font-semibold text-gray-900 mb-2">Dominant Colors</h4>
                        <div class="space-y-2">${colorsHtml}</div>
                    </div>
                `;

                // Additional Primary Colors section (computed from dominant colors)
                const primaryList = aggregatePrimaryFromDominantJS(imageData.colors);
                if (primaryList.length > 0) {
                    const primHtml = primaryList.map(pc => `
                        <span class="px-2 py-0.5 rounded-full text-xs bg-gray-100 text-gray-700 border">${pc.name} ${pc.percentage}%</span>
                    `).join(' ');
                    metadataHtml += `
                        <div>
                            <h4 class="font-semibold text-gray-900 mb-2">Primary Colors</h4>
                            <div class="flex flex-wrap gap-1">${primHtml}</div>
                        </div>
                    `;
                }
            }
            
            if (imageData.aiProcessed) {
                metadataHtml += `
                    <div>
                        <h4 class="font-semibold text-gray-900 mb-2">AI-Generated Metadata</h4>
                        <div class="space-y-2">
                            <div class="text-sm">
                                <div class="font-medium">Caption:</div>
                                <div class="text-gray-500">${imageData.caption}</div>
                            </div>
                            <div class="text-sm">
                                <div class="font-medium">Tags:</div>
                                <div class="text-gray-500">${imageData.tags.join(', ')}</div>
                            </div>
                            <div class="text-sm">
                                <div class="font-medium">All Tags:</div>
                                <div class="text-gray-500">${imageData.allTags.map(tag => `${tag.tag} (${tag.percentage}%)`).join(', ')}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            metadataHtml += '</div>';
            modalMetadata.innerHTML = metadataHtml;
            imageModal.classList.add('show');
        }

        function hideModal() {
            imageModal.classList.remove('show');
        }

        function showProgress(show) {
            uploadProgress.classList.toggle('hidden', !show);
        }

        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = `${current}/${total}`;
        }

        function updateStatus() {
            loadedCount.textContent = testResults.total;
            successCount.textContent = testResults.successful;
            failedCount.textContent = testResults.failed;
            
            if (testResults.failed > 0) {
                uploadStatus.innerHTML = `
                    <div class="status-badge status-warning">
                        <i class="fas fa-exclamation-triangle mr-1"></i>
                        ${testResults.successful} successful, ${testResults.failed} failed
                    </div>
                `;
            } else if (testResults.successful > 0) {
                uploadStatus.innerHTML = `
                    <div class="status-badge status-success">
                        <i class="fas fa-check mr-1"></i>
                        All ${testResults.successful} images loaded successfully!
                    </div>
                `;
            }
        }

        function clearAllImages() {
            if (confirm('Clear all test results?')) {
                loadedImages = [];
                testResults = { total: 0, successful: 0, failed: 0, errors: [] };
                imageGrid.innerHTML = `
                    <div class="col-span-full text-center py-12 text-gray-500">
                        <i class="fas fa-images text-4xl mb-4"></i>
                        <p class="text-lg">No images uploaded yet</p>
                        <p class="text-sm">Upload some images to start testing!</p>
                    </div>
                `;
                updateStatus();
                uploadStatus.innerHTML = '';
            }
        }

        function exportTestResults() {
            const results = {
                timestamp: new Date().toISOString(),
                summary: testResults,
                images: loadedImages.map(img => ({
                    name: img.name,
                    size: img.size,
                    type: img.type,
                    dimensions: img.dimensions,
                    loadSuccess: img.loadSuccess,
                    error: img.error,
                    colorsCount: img.colors ? img.colors.length : 0
                }))
            };
            
            const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `image-test-results-${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function updateProgress(current, total) {
            const percentage = (current / total) * 100;
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = `${current}/${total}`;
        }

        function updateSort() {
            const sortValue = sortBy.value;
            let sortedImages = [];
            switch (sortValue) {
                case 'newest':
                    sortedImages = loadedImages.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    break;
                case 'oldest':
                    sortedImages = loadedImages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                    break;
                case 'name-asc':
                    sortedImages = loadedImages.sort((a, b) => a.name.localeCompare(b.name));
                    break;
                case 'name-desc':
                    sortedImages = loadedImages.sort((a, b) => b.name.localeCompare(a.name));
                    break;
                case 'primary-asc':
                    sortedImages = loadedImages.sort((a, b) => getPrimaryColor(a).localeCompare(getPrimaryColor(b)));
                    break;
                case 'primary-desc':
                    sortedImages = loadedImages.sort((a, b) => getPrimaryColor(b).localeCompare(getPrimaryColor(a)));
                    break;
                default:
                    sortedImages = loadedImages;
            }
            imageGrid.innerHTML = '';
            sortedImages.forEach(image => renderImage(image));
            if (typeof refitColorRows === 'function') { refitColorRows(); } else { fitAllColorRows(); }
        }

        function updateFilter() {
            const filterTagValue = filterTag.value;
            let filteredImages = loadedImages;
            
            if (filterTagValue !== '') {
                filteredImages = loadedImages.filter(image => image.tags.includes(filterTagValue));
            }
            
            imageGrid.innerHTML = '';
            filteredImages.forEach(image => renderImage(image));
            if (typeof refitColorRows === 'function') { refitColorRows(); } else { fitAllColorRows(); }
        }

        function updateFilterPrimary() {
            const value = (filterPrimary.value || '').toLowerCase();
            let filtered = loadedImages;
            if (value !== '') {
                filtered = loadedImages.filter(img => {
                    try {
                        const list = aggregatePrimaryFromDominantJS(img.colors || []);
                        return list.some(pc => (pc.name || '').toLowerCase() === value && (parseFloat(pc.percentage) || 0) > 0);
                    } catch (e) {
                        return getPrimaryColor(img).toLowerCase() === value; // fallback to top primary
                    }
                });
            }
            imageGrid.innerHTML = '';
            filtered.forEach(image => renderImage(image));
            if (typeof refitColorRows === 'function') { refitColorRows(); } else { fitAllColorRows(); }
        }

        function updateSearch() {
            const searchQuery = searchInput.value.toLowerCase().trim();
            let searchedImages = loadedImages;
            
            if (searchQuery !== '') {
                searchedImages = loadedImages.filter(image => {
                    // Build a combined searchable string including colors
                    const parts = [];
                    // filename
                    if (image.name) parts.push(String(image.name).toLowerCase());
                    // caption
                    if (image.caption) parts.push(String(image.caption).toLowerCase());
                    // tags (strings or objects with .tag)
                    if (Array.isArray(image.tags)) {
                        for (const t of image.tags) {
                            if (typeof t === 'string') parts.push(t.toLowerCase());
                            else if (t && t.tag) parts.push(String(t.tag).toLowerCase());
                        }
                    }
                    // allTags
                    if (Array.isArray(image.allTags)) {
                        for (const t of image.allTags) {
                            if (typeof t === 'string') parts.push(t.toLowerCase());
                            else if (t && t.tag) parts.push(String(t.tag).toLowerCase());
                        }
                    }
                    // color terms (names, shades, hex, temperature, percentages)
                    if (Array.isArray(image.colors)) {
                        for (const c of image.colors) {
                            const name = (c.name || '').toLowerCase();
                            const shade = (c.shade || '').toLowerCase();
                            const hex = (c.hex || '').toLowerCase();
                            const temp = (c.temperature || '').toLowerCase();
                            const perc = c.percentage;
                            const percOk = (perc !== undefined && perc !== null && !isNaN(perc) && parseFloat(perc) >= 1.0);
                            // push hex and temperature unconditionally
                            if (hex) parts.push(hex);
                            if (temp) parts.push(temp);
                            // gate name/shade on percentage to reduce noise
                            if (percOk) {
                                // Special handling for gray/grey: ensure hex maps to primary gray
                                const isGrayTerm = (t) => t === 'gray' || t === 'grey';
                                let allowGray = true;
                                if (hex && (isGrayTerm(name) || isGrayTerm(shade))) {
                                    const m = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
                                    if (m) {
                                        const r = parseInt(m[1], 16), g = parseInt(m[2], 16), b = parseInt(m[3], 16);
                                        allowGray = (mapRgbToPrimaryJS(r, g, b) === 'gray');
                                    }
                                }
                                if (name && (allowGray || !isGrayTerm(name))) {
                                    parts.push(name);
                                    parts.push(name.replace('gray','grey'));
                                    parts.push(name.replace('grey','gray'));
                                }
                                if (shade && (allowGray || !isGrayTerm(shade))) {
                                    parts.push(shade);
                                    parts.push(shade.replace('gray','grey'));
                                    parts.push(shade.replace('grey','gray'));
                                }
                            }
                            // percentage numeric variants
                            if (perc !== undefined && perc !== null && !isNaN(perc)) {
                                const pf = parseFloat(perc);
                                const pi = Math.round(pf);
                                parts.push(String(pi));
                                parts.push(`${pi}%`);
                                const p1 = Math.round(pf * 10) / 10;
                                if (p1 !== pi) { parts.push(String(p1)); parts.push(`${p1}%`); }
                            }
                        }
                    }
                    // also include aggregated primary colors
                    try {
                        const primList = aggregatePrimaryFromDominantJS(image.colors || []);
                        for (const pc of primList) {
                            const pp = pc.percentage;
                            const n = (pc.name || '').toLowerCase();
                            // Only include name when percentage is meaningful to avoid false positives
                            if (n && pp !== undefined && pp !== null && !isNaN(pp) && parseFloat(pp) > 0.5) {
                                parts.push(n);
                                parts.push(n.replace('gray','grey'));
                                parts.push(n.replace('grey','gray'));
                            }
                            if (pp !== undefined && pp !== null && !isNaN(pp)) {
                                const ppi = Math.round(parseFloat(pp));
                                parts.push(String(ppi));
                                parts.push(`${ppi}%`);
                                const pp1 = Math.round(parseFloat(pp) * 10) / 10;
                                if (pp1 !== ppi) { parts.push(String(pp1)); parts.push(`${pp1}%`); }
                            }
                        }
                    } catch (e) { /* ignore */ }

                    const combined = parts.filter(Boolean).join(' ');
                    if (window.DEBUG_SEARCH && /\bgray\b|\bgrey\b/.test(searchQuery)) {
                        console.log('[DEBUG_SEARCH] Image:', image.name, { parts, combined });
                    }
                    return combined.includes(searchQuery);
                });
            }
            
            // Clear and re-render filtered images
            imageGrid.innerHTML = '';
            if (searchedImages.length === 0 && searchQuery !== '') {
                imageGrid.innerHTML = `
                    <div class="col-span-full text-center py-12 text-gray-500">
                        <i class="fas fa-search text-4xl mb-4"></i>
                        <p class="text-lg">No images found for "${searchQuery}"</p>
                        <p class="text-sm">Try searching for colors like \"gray 26.2%\", hex like \"#808080\", or tags/captions</p>
                    </div>
                `;
            } else if (searchedImages.length === 0) {
                imageGrid.innerHTML = `
                    <div class="col-span-full text-center py-12 text-gray-500">
                        <i class="fas fa-images text-4xl mb-4"></i>
                        <p class="text-lg">No images uploaded yet</p>
                        <p class="text-sm">Upload some images to start testing!</p>
                    </div>
                `;
            } else {
                searchedImages.forEach(image => renderImage(image));
            }
            if (typeof refitColorRows === 'function') { refitColorRows(); } else { fitAllColorRows(); }
        }

        function updateGridSize() {
            const gridSize = gridSizeSlider.value;
            gridSizeValue.textContent = `${gridSize}px`;
            imageGrid.style.gridTemplateColumns = `repeat(auto-fill, minmax(${gridSize}px, 1fr))`;
            imageGrid.style.setProperty('--thumb-h', `${gridSize}px`);
            if (typeof refitColorRows === 'function') { refitColorRows(); } else { fitAllColorRows(); }
        }

        function debounce(func, wait = 100) {
            let timeout;
            return function(...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    func.apply(this, args);
                }, wait);
            };
        }

        function fitColorRow(row) {
            if (!row) return;
            const circles = row.querySelectorAll('.color-circle');
            const n = circles.length;
            if (!n) return;
            const rowStyles = getComputedStyle(row);
            const gapPx = parseFloat(rowStyles.gap) || 8;
            const rowWidth = row.clientWidth;
            const maxSize = 32; // px
            const minSize = 10; // px
            const available = Math.max(0, rowWidth - (n - 1) * gapPx);
            let size = Math.floor(available / n);
            size = Math.max(minSize, Math.min(maxSize, size));
            circles.forEach(c => {
                c.style.width = `${size}px`;
                c.style.height = `${size}px`;
            });
            row.style.flexWrap = 'nowrap';
        }

        function fitAllColorRows() {
            const colorRows = document.querySelectorAll('.color-row');
            colorRows.forEach(fitColorRow);
        }

        
    </script>
</body>
</html>
